---
title: SSEé•¿è¿æ¥æŠ€æœ¯-EventSource
excerpt: EventSourceè‡ªå®šä¹‰Headerçš„å¸¸è§å®ç°æ–¹æ¡ˆ
createTime: 2025-01-07
cover: https://upyun-oss.mu00.cn/20250107114723369.png
tags:
  - EventSource
  - SSE
---

## EventSource

### ç®€ä»‹

`SSEï¼ˆServer-Sent Eventsï¼‰`æ˜¯ä¸€ç§åŸºäº HTTP åè®®ï¼Œç”¨äºå®ç°æœåŠ¡å™¨ä¸»åŠ¨å‘å®¢æˆ·ç«¯æ¨é€æ•°æ®çš„æŠ€æœ¯ã€‚å®ƒåœ¨å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨ä¹‹é—´å»ºç«‹ä¸€æ¡æŒä¹…åŒ–è¿æ¥ï¼Œå¹¶é€šè¿‡è¿™æ¡è¿æ¥å®ç°æœåŠ¡å™¨å‘å®¢æˆ·ç«¯çš„å®æ—¶æ•°æ®æ¨é€ï¼Œè€Œå®¢æˆ·ç«¯ä¸èƒ½å‘é€æ•°æ®ç»™æœåŠ¡ç«¯

**ç‰¹ç‚¹**

- å•å‘é€šä¿¡
- å®æ—¶æ¨é€
- è½»é‡çº§
- æ”¯æŒè·¨åŸŸã€ä½¿ç”¨ç®€å•ã€æ”¯æŒè‡ªåŠ¨é‡è¿

**é€‚åˆåœºæ™¯**

- æ•°æ®å¤§å±
- æ¶ˆæ¯æ¨é€
- è‚¡ç¥¨äº¤æ˜“
- åœ¨çº¿èŠå¤©

**æœ€è‡´å‘½ç¼ºç‚¹**ï¼šæ— æ³•æºå¸¦è‡ªå®šä¹‰è¯·æ±‚å¤´`Header`ï¼Œåªæ”¯æŒ`Get`è¯·æ±‚ï¼›

### ç®€å•ä½¿ç”¨

```js
// åˆ›å»º EventSource å®ä¾‹
const evtSource = new EventSource("http://localhost:3000/events");

// ç›‘å¬æ¶ˆæ¯
evtSource.onmessage = function (event) {
  console.log("æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼š", event);
};

// ç›‘å¬è¿æ¥æ‰“å¼€
evtSource.onopen = function () {
  console.log("è¿æ¥å·²å»ºç«‹");
};

// ç›‘å¬é”™è¯¯
evtSource.onerror = function (err) {
  console.error("EventSource å‘ç”Ÿé”™è¯¯:", err);
};
```

## ğŸ”¥SSE.JS

### ç®€ä»‹

`sse.js` æ˜¯ JavaScript çš„çµæ´» EventSource æ›¿ä»£å“ï¼ˆå®Œå…¨å…¼å®¹çš„ EventSource polyfillï¼‰ï¼Œæ—¨åœ¨ä½¿ç”¨æœåŠ¡å™¨å‘é€äº‹ä»¶ ï¼ˆSSEï¼‰ æµï¼Œæ¯”æ ‡å‡† EventSource å…·æœ‰æ›´å¤šçš„æ§åˆ¶å’Œé…ç½®ã€‚

**ç‰¹ç‚¹**

- æ”¯æŒè‡ªå®šä¹‰`Header`
- æ”¯æŒ`POST`è¯·æ±‚ç±»å‹

GIthubï¼š[sse.js](https://github.com/mpetazzoni/sse.js)

### é£Ÿç”¨æ–‡æ¡£

1. å®‰è£…

```bash
npm install sse.js
```

2. ç”¨æ³•

```js
import { SSE } from "sse.js";

// åˆ›å»º SSE å®ä¾‹
var source = new SSE("http://192.168.7.165:3000/events", {
  headers: {
    "X-App": "MyApp",
    "X-Token": "my-custom-token",
  },
});

// ç›‘å¬æ¶ˆæ¯
source.onmessage = function (event) {
  console.log("æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼š", event);
};

// ç›‘å¬è¿æ¥æ‰“å¼€
source.onopen = function () {
  console.log("SSE è¿æ¥å·²å»ºç«‹");
};

// ç›‘å¬é”™è¯¯
source.onerror = function (err) {
  console.error("EventSource å‘ç”Ÿé”™è¯¯:", err);
};
```

## FetchEventSource

### ç®€ä»‹

`FetchEventSource `æä¾›äº†æ›´å¤šçš„çµæ´»æ€§å’Œå®šåˆ¶èƒ½åŠ›ï¼Œèƒ½å¤Ÿå®ç°å¦‚è‡ªåŠ¨é‡è¯•ã€èº«ä»½éªŒè¯ã€è‡ªå®šä¹‰äº‹ä»¶å¤„ç†ç­‰å¤æ‚åŠŸèƒ½

**ç‰¹ç‚¹**

- æ”¯æŒè‡ªå®šä¹‰`Header`

GIthubï¼š[FetchEventSource ](https://github.com/Azure/fetch-event-source)

### é£Ÿç”¨æ–‡æ¡£

1. å®‰è£…

```bash
npm install @microsoft/fetch-event-source
```

2. ç”¨æ³•

```js
import { fetchEventSource } from "@microsoft/fetch-event-source";

fetchEventSource("http://192.168.7.165:3000/events", {
  headers: {
    "X-App": "MyApp",
    "X-Token": "my-custom-token",
  },
  onmessage(event) {
    console.log("æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼š", event);
  },
});
```

## EventSourcePolyfill

### ç®€ä»‹

`EventSourcePolyfill`æ˜¯ä¸€ä¸ªç”¨äºå®ç° Server-Sent Events (SSE) çš„ polyfill åº“ï¼›

æä¾›äº†å¯¹ä¸æ”¯æŒåŸç”Ÿ EventSource æ¥å£çš„æµè§ˆå™¨çš„æ”¯æŒï¼Œä½¿å¾—å¼€å‘è€…å¯ä»¥åœ¨æ‰€æœ‰ç°ä»£æµè§ˆå™¨ä¸­ä½¿ç”¨ SSE æŠ€æœ¯ã€‚

**ç‰¹ç‚¹**

- æ”¯æŒä½ç‰ˆæœ¬æµè§ˆå™¨
- æ”¯æŒè‡ªå®šä¹‰`Header`

GIthubï¼š[EventSourcePolyfill](https://github.com/Yaffle/EventSource/)

### é£Ÿç”¨æ–‡æ¡£

```js
// åˆ›å»º EventSourcePolyfill å®ä¾‹
const evtSource = new EventSourcePolyfill("http://192.168.7.165:3000/events", {
  headers: {
    "X-App": "MyApp",
    "X-Token": "my-custom-token",
  },
});

// ç›‘å¬æ¶ˆæ¯
evtSource.onmessage = function (event) {
  console.log("æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼š", event);
};

// ç›‘å¬è¿æ¥æ‰“å¼€
evtSource.onopen = function () {
  console.log("SSE è¿æ¥å·²å»ºç«‹");
};

// ç›‘å¬é”™è¯¯
evtSource.onerror = function (err) {
  console.error("EventSource å‘ç”Ÿé”™è¯¯:", err);
};
```

## ModernEventSource-è‡ªå®šä¹‰å®ç°

### å®ç°

::: tabs
@tab JavaScript

```js :collapsed-lines
/**
 * é»˜è®¤äº‹ä»¶è§£æå™¨ç±»
 * @class
 */
class DefaultEventParser {
  /**
   * è§£æäº‹ä»¶å­—ç¬¦ä¸²
   * @param {string} eventString - è¦è§£æçš„äº‹ä»¶å­—ç¬¦ä¸²
   * @returns {string|null} è§£æåçš„æ•°æ®ï¼Œå¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®åˆ™è¿”å› null
   */
  parse(eventString) {
    const lines = eventString
      .split("\n")
      .map((line) => line.trim())
      .filter(Boolean);
    return lines.length > 0 ? lines.join("\n") : null;
  }
}

/**
 * è‡ªå®šä¹‰äº‹ä»¶æºç±»ï¼Œç”¨äºå¤„ç†æœåŠ¡å™¨å‘é€äº‹ä»¶ï¼ˆSSEï¼‰
 * @class
 */
class CustomEventSource {
  /**
   * åˆ›å»ºä¸€ä¸ªæ–°çš„ CustomEventSource å®ä¾‹
   * @param {string} url - æœåŠ¡å™¨äº‹ä»¶æºçš„ URL
   * @param {Object} [options={}] - é…ç½®é€‰é¡¹
   * @param {Object} [options.headers={}] - è¯·æ±‚å¤´
   * @param {boolean} [options.autoReconnect=true] - æ˜¯å¦è‡ªåŠ¨é‡è¿
   * @param {number} [options.reconnectDelay=3000] - é‡è¿å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   * @param {number} [options.maxReconnectAttempts=5] - æœ€å¤§é‡è¿å°è¯•æ¬¡æ•°
   * @param {boolean} [options.autoManageVisibility=true] - æ˜¯å¦è‡ªåŠ¨ç®¡ç†é¡µé¢å¯è§æ€§
   * @param {EventParser} [eventParser] - è‡ªå®šä¹‰äº‹ä»¶è§£æå™¨
   */
  constructor(url, options = {}, eventParser) {
    this.url = url;
    this.headers = options.headers || {};
    this.onmessage = null;
    this.onerror = null;
    this.onopen = null;

    // é‡è¿é…ç½®
    this.autoReconnect = options.autoReconnect ?? true;
    this.reconnectDelay = options.reconnectDelay || 3000;
    this.maxReconnectAttempts = options.maxReconnectAttempts || 5;

    // é¡µé¢å¯è§æ€§ç®¡ç†
    this.autoManageVisibility = options.autoManageVisibility ?? true; // é»˜è®¤å¼€å¯å¯è§æ€§ç®¡ç†
    this.isConnected = false;
    this.wasConnected = false; // è®°å½•é¡µé¢éšè—å‰çš„è¿æ¥çŠ¶æ€

    this.reconnectAttempts = 0;
    this.abortController = null;

    if (this.autoManageVisibility) {
      this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      document.addEventListener(
        "visibilitychange",
        this.handleVisibilityChange
      );
    }

    if (document.visibilityState === "visible") {
      this.connect();
    }

    this.eventParser = eventParser || new DefaultEventParser();
  }

  /**
   * å¤„ç†é¡µé¢å¯è§æ€§å˜åŒ–
   * @private
   */
  handleVisibilityChange() {
    if (document.visibilityState === "visible") {
      // é¡µé¢å˜ä¸ºå¯è§æ—¶ï¼Œå¦‚æœä¹‹å‰æ˜¯è¿æ¥çŠ¶æ€ï¼Œåˆ™é‡æ–°è¿æ¥
      if (this.wasConnected) {
        this.connect();
      }
    } else {
      // é¡µé¢éšè—æ—¶ï¼Œè®°å½•å½“å‰çŠ¶æ€å¹¶æ–­å¼€è¿æ¥
      this.wasConnected = this.isConnected;
      if (this.isConnected) {
        this.close();
      }
    }
  }

  /**
   * è¿æ¥åˆ°äº‹ä»¶æº
   * @returns {Promise<void>}
   */
  async connect() {
    if (this.isConnected) {
      return;
    }

    try {
      this.abortController = new AbortController();

      const response = await fetch(this.url, {
        headers: this.headers,
        signal: this.abortController.signal,
      });

      this.isConnected = true;
      if (this.onopen) {
        this.onopen();
      }

      this.reconnectAttempts = 0;

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const messages = buffer.split("\n\n");
        buffer = messages.pop() || "";

        messages.forEach((message) => {
          const data = this.parseEvent(message);
          if (data && this.onmessage) {
            this.onmessage({ data });
          }
        });
      }
    } catch (error) {
      if (error.name === "AbortError") {
        console.log("è¿æ¥è¢«ä¸»åŠ¨ä¸­æ–­");
        return;
      }

      this.handleError(error);
    } finally {
      this.isConnected = false;
    }
  }

  /**
   * è§£æäº‹ä»¶æ•°æ®
   * @private
   * @param {string} eventString - è¦è§£æçš„äº‹ä»¶å­—ç¬¦ä¸²
   * @returns {string|null} è§£æåçš„æ•°æ®
   */
  parseEvent(eventString) {
    return this.eventParser.parse(eventString);
  }

  /**
   * å°è¯•é‡æ–°è¿æ¥
   * @private
   * @returns {Promise<void>}
   */
  async reconnect() {
    if (!this.autoReconnect) {
      console.log("è‡ªåŠ¨é‡è¿å·²ç¦ç”¨");
      return;
    }

    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.log("è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿");
      this.close();
      return;
    }

    this.reconnectAttempts++;
    console.log(
      `å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})`
    );

    this.close();

    await new Promise((resolve) => setTimeout(resolve, this.reconnectDelay));
    this.connect();
  }

  /**
   * å¤„ç†é”™è¯¯
   * @private
   * @param {Error} error - é”™è¯¯å¯¹è±¡
   */
  handleError(error) {
    if (this.onerror) {
      this.onerror(error);
    }
    this.reconnect();
  }

  /**
   * å…³é—­è¿æ¥
   */
  close() {
    this.isConnected = false;
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }

  /**
   * é”€æ¯å®ä¾‹ï¼Œæ¸…ç†èµ„æº
   */
  destroy() {
    this.close();
    if (this.autoManageVisibility) {
      document.removeEventListener(
        "visibilitychange",
        this.handleVisibilityChange
      );
    }
  }
}

export default CustomEventSource;
```

@tab Typescript

```typescript :collapsed-lines
// è‡ªå®šä¹‰äº‹ä»¶æºé…ç½®é€‰é¡¹æ¥å£
interface CustomEventSourceOptions {
  headers?: Record<string, string>; // æ·»åŠ  headers é€‰é¡¹
  autoReconnect?: boolean; // æ˜¯å¦è‡ªåŠ¨é‡è¿
  reconnectDelay?: number; // é‡è¿å»¶è¿Ÿæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  maxReconnectAttempts?: number; // æœ€å¤§é‡è¿å°è¯•æ¬¡æ•°
  autoManageVisibility?: boolean; // æ˜¯å¦è‡ªåŠ¨ç®¡ç†é¡µé¢å¯è§æ€§
}

// è‡ªå®šä¹‰äº‹ä»¶å¯¹è±¡æ¥å£
interface CustomEventSourceEvent {
  data: string; // äº‹ä»¶æ•°æ®
}

// äº‹ä»¶å¤„ç†å™¨ç±»å‹å®šä¹‰
type EventHandler = (event: CustomEventSourceEvent) => void; // æ¶ˆæ¯å¤„ç†å™¨
type ErrorHandler = (error: Error) => void; // é”™è¯¯å¤„ç†å™¨
type OpenHandler = () => void; // è¿æ¥æ‰“å¼€å¤„ç†å™¨

// äº‹ä»¶è§£æå™¨æ¥å£
interface EventParser {
  parse(eventString: string): string | null; // è§£æäº‹ä»¶å­—ç¬¦ä¸²
}

// é»˜è®¤äº‹ä»¶è§£æå™¨å®ç°
class DefaultEventParser implements EventParser {
  parse(eventString: string): string | null {
    // å°†è¾“å…¥æŒ‰è¡Œåˆ†å‰²ï¼Œå»é™¤ç©ºç™½å­—ç¬¦ï¼Œè¿‡æ»¤ç©ºè¡Œï¼Œå¹¶é‡æ–°ç»„åˆ
    const lines = eventString
      .split("\n")
      .map((line) => line.trim())
      .filter(Boolean);
    return lines.length > 0 ? lines.join("\n") : null;
  }
}

class CustomEventSource {
  private url: string;
  private headers: Record<string, string>;
  private autoReconnect: boolean;
  private reconnectDelay: number;
  private maxReconnectAttempts: number;
  private autoManageVisibility: boolean;
  private isConnected: boolean;
  private wasConnected: boolean;
  private reconnectAttempts: number;
  private abortController: AbortController | null;
  private eventParser: EventParser;

  public onmessage: EventHandler | null;
  public onerror: ErrorHandler | null;
  public onopen: OpenHandler | null;

  constructor(
    url: string,
    options: CustomEventSourceOptions = {},
    eventParser?: EventParser
  ) {
    this.url = url;
    this.headers = options.headers || {};
    this.onmessage = null;
    this.onerror = null;
    this.onopen = null;

    // é‡è¿é…ç½®
    this.autoReconnect = options.autoReconnect ?? true;
    this.reconnectDelay = options.reconnectDelay || 3000;
    this.maxReconnectAttempts = options.maxReconnectAttempts || 5;

    // é¡µé¢å¯è§æ€§ç®¡ç†
    this.autoManageVisibility = options.autoManageVisibility ?? true;
    this.isConnected = false;
    this.wasConnected = false;

    this.reconnectAttempts = 0;
    this.abortController = null;

    if (this.autoManageVisibility) {
      this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
      document.addEventListener(
        "visibilitychange",
        this.handleVisibilityChange
      );
    }

    if (document.visibilityState === "visible") {
      this.connect();
    }

    this.eventParser = eventParser || new DefaultEventParser();
  }

  private handleVisibilityChange(): void {
    if (document.visibilityState === "visible") {
      if (this.wasConnected) {
        this.connect();
      }
    } else {
      this.wasConnected = this.isConnected;
      if (this.isConnected) {
        this.close();
      }
    }
  }

  public async connect(): Promise<void> {
    if (this.isConnected) {
      return;
    }

    try {
      this.abortController = new AbortController();

      const response = await fetch(this.url, {
        headers: this.headers,
        signal: this.abortController.signal,
      });

      this.isConnected = true;
      if (this.onopen) {
        this.onopen();
      }

      this.reconnectAttempts = 0;

      const reader = response.body!.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const messages = buffer.split("\n\n");
        buffer = messages.pop() || "";

        messages.forEach((message) => {
          const data = this.parseEvent(message);
          if (data && this.onmessage) {
            this.onmessage({ data });
          }
        });
      }
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        console.log("è¿æ¥è¢«ä¸»åŠ¨ä¸­æ–­");
        return;
      }

      this.handleError(error as Error);
    } finally {
      this.isConnected = false;
    }
  }

  private parseEvent(eventString: string): string | null {
    return this.eventParser.parse(eventString);
  }

  private async reconnect(): Promise<void> {
    if (!this.autoReconnect) {
      console.log("è‡ªåŠ¨é‡è¿å·²ç¦ç”¨");
      return;
    }

    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      console.log("è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢é‡è¿");
      this.close();
      return;
    }

    this.reconnectAttempts++;
    console.log(
      `å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})`
    );

    this.close();

    await new Promise((resolve) => setTimeout(resolve, this.reconnectDelay));
    this.connect();
  }

  private handleError(error: Error): void {
    if (this.onerror) {
      this.onerror(error);
    }
    this.reconnect();
  }

  public close(): void {
    this.isConnected = false;
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }

  public destroy(): void {
    this.close();
    if (this.autoManageVisibility) {
      document.removeEventListener(
        "visibilitychange",
        this.handleVisibilityChange
      );
    }
  }
}

export default CustomEventSource;
```

:::

### é£Ÿç”¨æ–‡æ¡£

```js
import ModernEventSource from "./ModernEventSource.js";

const eventSource = new ModernEventSource("http://localhost:3000/events", {
  autoReconnect: true, // å¯ç”¨è‡ªåŠ¨é‡è¿
  reconnectDelay: 2000, // 2ç§’åé‡è¿
  maxReconnectAttempts: 3, // æœ€å¤šé‡è¿3æ¬¡
  autoManageVisibility: true, // å¯ç”¨é¡µé¢å¯è§æ€§ç®¡ç†
  headers: {
    "X-App": "MyApp",
    "X-Token": "my-custom-token",
  },
});

eventSource.onopen = function () {
  console.log("è¿æ¥å·²å»ºç«‹");
};

eventSource.onmessage = function (event) {
  console.log("æ¥æ”¶åˆ°çš„æ¶ˆæ¯ï¼š", event);
};

eventSource.onerror = function (error) {
  console.error("SSE é”™è¯¯ï¼š", error);
};

// åœ¨é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
window.addEventListener("unload", () => {
  eventSource.destroy();
});
```
